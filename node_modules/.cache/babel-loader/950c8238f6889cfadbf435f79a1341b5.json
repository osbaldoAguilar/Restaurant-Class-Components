{"ast":null,"code":"var fs = require('fs');\n\nvar path = require('path');\n\nvar os = require('os');\n\nvar LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg; // Parser src into an Object\n\nfunction parse(src) {\n  var obj = {}; // Convert buffer to string\n\n  var lines = src.toString(); // Convert line breaks to same format\n\n  lines = lines.replace(/\\r\\n?/mg, '\\n');\n  var match;\n\n  while ((match = LINE.exec(lines)) != null) {\n    var key = match[1]; // Default undefined or null to empty string\n\n    var value = match[2] || ''; // Remove whitespace\n\n    value = value.trim(); // Check if double quoted\n\n    var maybeQuote = value[0]; // Remove surrounding quotes\n\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2'); // Expand newlines if double quoted\n\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n');\n      value = value.replace(/\\\\r/g, '\\r');\n    } // Add to object\n\n\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _log(message) {\n  console.log(\"[dotenv][DEBUG] \".concat(message));\n}\n\nfunction _resolveHome(envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath;\n} // Populates process.env from .env file\n\n\nfunction config(options) {\n  var dotenvPath = path.resolve(process.cwd(), '.env');\n  var encoding = 'utf8';\n  var debug = Boolean(options && options.debug);\n  var override = Boolean(options && options.override);\n\n  if (options) {\n    if (options.path != null) {\n      dotenvPath = _resolveHome(options.path);\n    }\n\n    if (options.encoding != null) {\n      encoding = options.encoding;\n    }\n  }\n\n  try {\n    // Specifying an encoding returns a string instead of a buffer\n    var parsed = DotenvModule.parse(fs.readFileSync(dotenvPath, {\n      encoding: encoding\n    }));\n    Object.keys(parsed).forEach(function (key) {\n      if (!Object.prototype.hasOwnProperty.call(process.env, key)) {\n        process.env[key] = parsed[key];\n      } else {\n        if (override === true) {\n          process.env[key] = parsed[key];\n        }\n\n        if (debug) {\n          if (override === true) {\n            _log(\"\\\"\".concat(key, \"\\\" is already defined in `process.env` and WAS overwritten\"));\n          } else {\n            _log(\"\\\"\".concat(key, \"\\\" is already defined in `process.env` and was NOT overwritten\"));\n          }\n        }\n      }\n    });\n    return {\n      parsed: parsed\n    };\n  } catch (e) {\n    if (debug) {\n      _log(\"Failed to load \".concat(dotenvPath, \" \").concat(e.message));\n    }\n\n    return {\n      error: e\n    };\n  }\n}\n\nvar DotenvModule = {\n  config: config,\n  parse: parse\n};\nmodule.exports.config = DotenvModule.config;\nmodule.exports.parse = DotenvModule.parse;\nmodule.exports = DotenvModule;","map":{"version":3,"sources":["/Users/osbaldoaguilar/doIt/fish-classes/node_modules/dotenv/lib/main.js"],"names":["fs","require","path","os","LINE","parse","src","obj","lines","toString","replace","match","exec","key","value","trim","maybeQuote","_log","message","console","log","_resolveHome","envPath","join","homedir","slice","config","options","dotenvPath","resolve","process","cwd","encoding","debug","Boolean","override","parsed","DotenvModule","readFileSync","Object","keys","forEach","prototype","hasOwnProperty","call","env","e","error","module","exports"],"mappings":"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","sourcesContent":["const fs = require('fs')\nconst path = require('path')\nconst os = require('os')\n\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg\n\n// Parser src into an Object\nfunction parse (src) {\n  const obj = {}\n\n  // Convert buffer to string\n  let lines = src.toString()\n\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/mg, '\\n')\n\n  let match\n  while ((match = LINE.exec(lines)) != null) {\n    const key = match[1]\n\n    // Default undefined or null to empty string\n    let value = (match[2] || '')\n\n    // Remove whitespace\n    value = value.trim()\n\n    // Check if double quoted\n    const maybeQuote = value[0]\n\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2')\n\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n')\n      value = value.replace(/\\\\r/g, '\\r')\n    }\n\n    // Add to object\n    obj[key] = value\n  }\n\n  return obj\n}\n\nfunction _log (message) {\n  console.log(`[dotenv][DEBUG] ${message}`)\n}\n\nfunction _resolveHome (envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath\n}\n\n// Populates process.env from .env file\nfunction config (options) {\n  let dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding = 'utf8'\n  const debug = Boolean(options && options.debug)\n  const override = Boolean(options && options.override)\n\n  if (options) {\n    if (options.path != null) {\n      dotenvPath = _resolveHome(options.path)\n    }\n    if (options.encoding != null) {\n      encoding = options.encoding\n    }\n  }\n\n  try {\n    // Specifying an encoding returns a string instead of a buffer\n    const parsed = DotenvModule.parse(fs.readFileSync(dotenvPath, { encoding }))\n\n    Object.keys(parsed).forEach(function (key) {\n      if (!Object.prototype.hasOwnProperty.call(process.env, key)) {\n        process.env[key] = parsed[key]\n      } else {\n        if (override === true) {\n          process.env[key] = parsed[key]\n        }\n\n        if (debug) {\n          if (override === true) {\n            _log(`\"${key}\" is already defined in \\`process.env\\` and WAS overwritten`)\n          } else {\n            _log(`\"${key}\" is already defined in \\`process.env\\` and was NOT overwritten`)\n          }\n        }\n      }\n    })\n\n    return { parsed }\n  } catch (e) {\n    if (debug) {\n      _log(`Failed to load ${dotenvPath} ${e.message}`)\n    }\n\n    return { error: e }\n  }\n}\n\nconst DotenvModule = {\n  config,\n  parse\n}\n\nmodule.exports.config = DotenvModule.config\nmodule.exports.parse = DotenvModule.parse\nmodule.exports = DotenvModule\n"]},"metadata":{},"sourceType":"script"}